/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, {useContext, useEffect, useRef} from 'react'
import {useGLTF, PerspectiveCamera, useAnimations} from '@react-three/drei'
import {GLTF} from 'three-stdlib'
import {useFrame, useThree} from "@react-three/fiber";
import {useViewportScroll} from "framer-motion";
import {AnimationAction} from "three";
import MousePositionContext from "../../../contexts/mouse-position-context";
import useDevice from "../../../hooks/use-device";

type GLTFResult = GLTF & {
    nodes: {
        Mesh_0: THREE.Mesh
    }
    materials: {
        Material_0: THREE.MeshStandardMaterial
    },
}

export default function Model({...props}: JSX.IntrinsicElements['group']) {
    const groupRef = useRef<THREE.Group>(null)
    const meshRef = useRef<THREE.Mesh>(null)
    const cameraRef = useRef<THREE.Camera>(null)
    const cursorCameraRef = useRef<THREE.Camera>(null)
    const {nodes, materials, animations} = useGLTF('/models/me-camera.glb') as GLTFResult
    const {actions} = useAnimations(animations, groupRef)
    const {scrollYProgress} = useViewportScroll();
    const canvasSize = useThree().size;
    const device = useDevice();


    const mousePositionRef = useContext(MousePositionContext).mousePositionRef;

    useEffect(() => {
        (actions["CameraAction.006"] as AnimationAction).play().paused = true;
    }, [actions]);

    useFrame((state) => {
        console.log(scrollYProgress.get());
        // Camera Scroll Movement
        const scroll = scrollYProgress.get();
        const action = actions["CameraAction.006"] as AnimationAction;

        action.time =
            THREE.MathUtils.lerp(action.time, action.getClip().duration * scroll, 0.05)

        if (!meshRef || !meshRef.current) {
            return;
        }

        // Mesh Bouncing
        const et = state.clock.elapsedTime
        meshRef.current.position.y = Math.sin((et + 2000) / 2) / 10
        meshRef.current.rotation.x = Math.sin((et + 2000) / 3) / 15
        meshRef.current.rotation.y = Math.cos((et + 2000) / 2) / 15
        meshRef.current.rotation.z = Math.sin((et + 2000) / 3) / 15

        // Camera Cursor Movement
        if (device === "small" || !cameraRef || !cameraRef.current || !mousePositionRef || !mousePositionRef.current || !cursorCameraRef || !cursorCameraRef.current) {
            return;
        }

        cursorCameraRef.current.rotation.x = -0.00005 * (mousePositionRef.current.clientY - canvasSize.height / 2)
        cursorCameraRef.current.rotation.z = 0.00005 * (mousePositionRef.current.clientX - canvasSize.width / 2)
    })

    return (
        <group ref={groupRef} {...props} dispose={null}>
            <group name="Camera" position={[-0.06, 1.36, 7.82]} rotation={[1.38, 0, 0]} ref={cameraRef}>
                <group ref={cursorCameraRef}>
                    <PerspectiveCamera
                        makeDefault far={100} near={0.1} fov={38.27} rotation={[-Math.PI / 2, 0, 0]}/>
                </group>
            </group>
            <group
                ref={meshRef}
            >
                <mesh
                    castShadow={true}
                    geometry={nodes.Mesh_0.geometry}
                    material={materials.Material_0}
                    rotation={[-0.1, 0.08, 0.07]}
                    scale={8.62}
                />
            </group>

        </group>
    )
}

useGLTF.preload('/models/me-camera.glb')
